// bpf-loader.c
// User-space loader for monitor.bpf.c using libbpf CO-RE

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>

#include <bpf/libbpf.h>

#include "monitor.skel.h"  // generated by bpftool

#define TASK_COMM_LEN 16

static volatile sig_atomic_t exiting;

// This struct must match the one in monitor.bpf.c
struct event {
    __u32 pid;
    __u32 ppid;
    __u32 uid;
    __u32 type;
    char comm[TASK_COMM_LEN];
    
    char filename[256];
    
    __u32 daddr;
    __u16 dport;
    __u16 _pad;
    
    __u64 count;
    
    __u64 mmap_addr;
    __u64 mmap_len;
    __u32 mmap_prot;
    __u32 mmap_flags;
};

static void handle_sigint(int sig) {
    exiting = 1;
}

static void print_ipv4(__u32 addr, __u16 port) {
    struct in_addr a = { .s_addr = addr };
    char ip[INET_ADDRSTRLEN] = {};
    inet_ntop(AF_INET, &a, ip, sizeof(ip));
    printf("%s:%u", ip, ntohs(port));
}

static void print_len_mmap_human(__u64 len) {
    const double KB = 1024.0;
    const double MB = 1024.0 * 1024.0;
    
    if (len >= (1UL << 20)) { // >= 1 MB
        double mb = (double)len / MB;
        printf("%.2f MB", mb);
    } else if (len >= 1024ULL) { // >= 1 KB
        double kb = (double)len / KB;
        printf("%.2f KB", kb);
    } else {
        printf("%llu B", (unsigned long long)len);
    }
}

static int handle_event(void *ctx, void *data, size_t len) {
    const char *filter_comm = ctx; // optional filter
    const struct event *e = data;
    char comm[TASK_COMM_LEN + 1];
    
    memcpy(comm, e->comm, TASK_COMM_LEN);
    comm[TASK_COMM_LEN] = '\0';
    
    if (filter_comm && filter_comm[0] != '\0') {
        if (strncmp(comm, filter_comm, TASK_COMM_LEN) != 0) {
            return 0;
        }
    }
    
    // timestamp is nice to have
    char ts[32];
    time_t t = time(NULL);
    struct tm tmp;
    localtime_r(&t, &tmp);
    strftime(ts, sizeof(ts), "%H:%M:%S", &tmp);
    
    printf("[%s] pid=%u ppid=%u uid=%u comm=%s ",
           ts, e->pid, e->ppid, e->uid, comm);
           
    switch(e->type) {
    case 0: // connect
        printf("EVENT=connect dst=");
        print_ipv4(e->daddr, e->dport);
        break;
    case 1: // open
        printf("EVENT=open    path=%s", e->filename);
        break;
    case 2: // write
        printf("EVENT=write   bytes=%llu",
               (unsigned long long)e->count);
        break;
    case 3: // rename
        printf("EVENT=rename  newpath=%s", e->filename);
        break;
    case 4: // mmap
        printf("EVENT=mmap    addr=0x%llx len=",
                (unsigned long long)e->mmap_addr);
        print_len_mmap_human(e->mmap_len);
        printf(" prot=0x%x flags=0x%x",e->mmap_prot, e->mmap_flags);
        break;
    default:
        printf("EVENT=unknown(%u)", e->type);
        break;
    }
    
    printf("\n");
    fflush(stdout);
    return 0;
}


int main(int argc, char *argv[], char *envp[]) {
    struct monitor_bpf *skel = NULL;
    struct ring_buffer *rb = NULL;
    int err;
    const char *filter_comm = NULL;
    
    if (argc == 3 && strcmp(argv[1], "--comm") == 0) {
        filter_comm = argv[2];  // filter events by name of the process, e.g.: "suspicious_demo"
    } else if (argc > 1) {
        fprintf(stderr, "Usage: %s [--comm COMM]\n", argv[0]);
        return 1;
    }
    
    libbpf_set_strict_mode(LIBBPF_STRICT_ALL);
    
    signal(SIGINT, handle_sigint);
    signal(SIGTERM, handle_sigint);
    
    // Open and load BPF application
    skel = monitor_bpf__open_and_load();
    if (!skel) {
        fprintf(stderr, "Failed to open/load BPF skeleton\n");
        return 1;
    }
    
    // Attach tracepoints
    err = monitor_bpf__attach(skel);
    if (err) {
        fprintf(stderr, "Failed to attach BPF programs: %d\n", err);
        goto cleanup;
    }
    
    printf("Attached. Monitoring connect/open/write/rename.\n");
    if (filter_comm) {
        printf("Filtering by comm=\"%s\".\n", filter_comm);
    }
    printf("Press Ctrl-C to exit.\n\n");
    
    // Set up ring buffer
    rb = ring_buffer__new(bpf_map__fd(skel->maps.events), handle_event, (void *)filter_comm, NULL);
    if (!rb) {
        fprintf(stderr, "Failed to create ring buffer\n");
        goto cleanup;
    }
    
    // Poll eents
    while (!exiting) {
        err = ring_buffer__poll(rb, 100); // 100 ms timeout
        if (err == -EINTR) {
            // interrupted by signal
            break;
        } else if (err < 0) {
            fprintf(stderr, "right_buffer__poll failed: %d\n", err);
            break;
        }
    }
    
cleanup:
    ring_buffer__free(rb);
    monitor_bpf__destroy(skel);
    return err != 0;
}

















